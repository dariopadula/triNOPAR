## Denominador de la ecuacion (2) (Es tambien lo que aparece en la ecuacion (3)) se devería de cancelar
Pj1 = colSums(pi_yj1_num)
## Ecuacion (2)
pi_yj1 = pi_yj1_num/Pj1
# Lo mismo para armar las ecuaciones 4 y 5
pi_yj0_num = (1 - curvaNOPAR)*pi_n
Pj0 = colSums(pi_yj0_num)
pi_yj0 = pi_yj0_num/Pj0
# Terminos de la esperanza de shanon
SHE0 = -colSums(log(pi_yj0^pi_yj0))*Pj0
SHE1 = -colSums(log(pi_yj1^pi_yj1))*Pj1
# Esperanza de la entropia de Shannon
SHE = data.frame(matrix(SHE0 + SHE1,nrow = 1,ncol = ncol(curvaNOPAR)))
colnames(SHE) = itemsNoms
if(length(seleit) !=0){
SHE=SHE[,!colnames(SHE) %in% seleit]
}
itsel = colnames(SHE)[which.min(SHE)]
}
### Seleccion Aleatoria
if(metodoSel %in% c('Random')) {
if(length(seleit) !=0){
itEliegibles = itemsNoms[!itemsNoms %in% seleit]
itsel = sample(itEliegibles,1)
}
itsel = sample(itemsNoms,1)
}
seleit = c(seleit,itsel) # Guarda el item
seleit
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
Psuj = iccFun(a,b,c,th)
raux=runif(1,0,1)
raux
Psuj
a
b
c
head(parametros)
itsel
head(bancTeor)
## Parametros verdaderos
parametros = bancTeor[,c('NombreIt','Modelo',paste0('P',1:3))]
rownames(parametros) = apply(parametros[,'NombreIt','Modelo'],1,function(xx) paste(xx,collapse = ''))
rownames(parametros) = apply(parametros[,c('NombreIt','Modelo')],1,function(xx) paste(xx,collapse = ''))
parametros
parametros$P3 = ifelse(is.na(parametros$P3),0,parametros$P3)
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
a
b
c
Psuj = iccFun(a,b,c,th)
Psuj
sujtai = rnorm(100)
epsilon = 0.01
minit = 10
maxit = 20
curvaNOPAR = NULL
res = TAIgeneric(sujtai,
epsilon,
minit,
maxit,
curvaNOPAR,
parametros,
parEst,
itemsSelec = c('InfoFun'),
matrizSelect = infoFunPar,
seqTheta = puntosNP)
for(s in 1:length(sujtai)){
if((s %% 1000) == 0) print(s)
metodoSel = itemsSelec[1] # TOma el primero por defecto
### Nombre de los items
itemsNoms = rownames(parametros)
resp=numeric(0)
vero=1
th=sujtai[s]
th_est=runif(1,0.3,0.7)
delta=1
control=0
seleit=NULL
if(metodoSel %in% c('InfoFun','KL')) matSelAux = matrizSelect
#seleccion del item
while(delta > epsilon  & length(seleit)<maxit){
th_vie=th_est
#### Metodo de informacion de item isotonico  o KL
if(metodoSel %in% c('InfoFun','KL')) {
auxiliar = which.min(abs(seqTheta - th_est)) # Selecciona fila (theta para buscar en la matriz)
itsel = colnames(matSelAux)[which.max(matSelAux[auxiliar,])] # Selecciona el nombre del items con max Info o KL
matSelAux = matSelAux[,colnames(matSelAux) != itsel]
}
#### Metodo Shannon Entrophy
if(metodoSel %in% c('ESH')) {
veroPrev = vero
## Transforma verosimilitud en una matriz con la dimension de curvaNOPAR
veroPrev = matrix(veroPrev,ncol = 1,nrow = nrow(curvaNOPAR),byrow = F)
## Normaliza para obtener el pi_n (Ecuacion 1)
pi_n = veroPrev/sum(veroPrev)
## Numerador de la ecuacion (2)
pi_yj1_num = curvaNOPAR*pi_n
## Denominador de la ecuacion (2) (Es tambien lo que aparece en la ecuacion (3)) se devería de cancelar
Pj1 = colSums(pi_yj1_num)
## Ecuacion (2)
pi_yj1 = pi_yj1_num/Pj1
# Lo mismo para armar las ecuaciones 4 y 5
pi_yj0_num = (1 - curvaNOPAR)*pi_n
Pj0 = colSums(pi_yj0_num)
pi_yj0 = pi_yj0_num/Pj0
# Terminos de la esperanza de shanon
SHE0 = -colSums(log(pi_yj0^pi_yj0))*Pj0
SHE1 = -colSums(log(pi_yj1^pi_yj1))*Pj1
# Esperanza de la entropia de Shannon
SHE = data.frame(matrix(SHE0 + SHE1,nrow = 1,ncol = ncol(curvaNOPAR)))
colnames(SHE) = itemsNoms
if(length(seleit) !=0){
SHE=SHE[,!colnames(SHE) %in% seleit]
}
itsel = colnames(SHE)[which.min(SHE)]
}
### Seleccion Aleatoria
if(metodoSel %in% c('Random')) {
if(length(seleit) !=0){
itEliegibles = itemsNoms[!itemsNoms %in% seleit]
itsel = sample(itEliegibles,1)
}
itsel = sample(itemsNoms,1)
}
seleit = c(seleit,itsel) # Guarda el item
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
Psuj = iccFun(a,b,c,th)
raux=runif(1,0,1)
if(raux<Psuj){respu=1}else{respu=0}
resp=c(resp,respu)
# Calcula la curva dependiendo si es NP o Parametrica
if(!is.null(curvaNOPAR)) {
curva = curvaNOPAR[,itsel]
} else {
aEst = parEst[itsel,'a']
bEst = parEst[itsel,'a']
cEst = parEst[itsel,'c']
curva = iccFun(aEst,bEst,cEst,grilla = qnorm(seqTheta))
}
#calcula verosimilitud
vero=vero*(curva^respu)*(1-curva)^(1-respu)
#plot(vero)
#estimacion de theta
if( length(unique(unlist(resp))) == 1 ){## solo aciertos o solo errores
delta=1
if(resp[1]==1){ th_est = 0.75+length(resp)*0.05
if(th_est>1){th_est=0.99}
} else { th_est = 0.25-length(resp)*0.05
if(th_est<0){th_est=0.01}
}
} else { ## si hay aciertos y errores
th_est=seqTheta[which.max(vero)]
if(length(resp)<minit){delta=1} else {delta=abs(th_est-th_vie)}
}
}
estima[s,1]=th_est
estima[s,2]=delta
estima[s,3]=length(resp)
estima[s,4]=pnorm(th)
}
######## FUNCION GENERICA PARA APLICAR TAI
TAIgeneric <- function(sujtai,
epsilon,
minit,
maxit,
curvaNOPAR,
parametros,
parEst,
itemsSelec = c('InfoFun','KL','ESH','Random'),
matrizSelect = MINOPARAUX,
seqTheta) {
estima=matrix(NA,nrow=length(sujtai),ncol=4)
for(s in 1:length(sujtai)){
if((s %% 1000) == 0) print(s)
metodoSel = itemsSelec[1] # TOma el primero por defecto
### Nombre de los items
itemsNoms = rownames(parametros)
resp=numeric(0)
vero=1
th=sujtai[s]
th_est=runif(1,0.3,0.7)
delta=1
control=0
seleit=NULL
if(metodoSel %in% c('InfoFun','KL')) matSelAux = matrizSelect
#seleccion del item
while(delta > epsilon  & length(seleit)<maxit){
th_vie=th_est
#### Metodo de informacion de item isotonico  o KL
if(metodoSel %in% c('InfoFun','KL')) {
auxiliar = which.min(abs(seqTheta - th_est)) # Selecciona fila (theta para buscar en la matriz)
itsel = colnames(matSelAux)[which.max(matSelAux[auxiliar,])] # Selecciona el nombre del items con max Info o KL
matSelAux = matSelAux[,colnames(matSelAux) != itsel]
}
#### Metodo Shannon Entrophy
if(metodoSel %in% c('ESH')) {
veroPrev = vero
## Transforma verosimilitud en una matriz con la dimension de curvaNOPAR
veroPrev = matrix(veroPrev,ncol = 1,nrow = nrow(curvaNOPAR),byrow = F)
## Normaliza para obtener el pi_n (Ecuacion 1)
pi_n = veroPrev/sum(veroPrev)
## Numerador de la ecuacion (2)
pi_yj1_num = curvaNOPAR*pi_n
## Denominador de la ecuacion (2) (Es tambien lo que aparece en la ecuacion (3)) se devería de cancelar
Pj1 = colSums(pi_yj1_num)
## Ecuacion (2)
pi_yj1 = pi_yj1_num/Pj1
# Lo mismo para armar las ecuaciones 4 y 5
pi_yj0_num = (1 - curvaNOPAR)*pi_n
Pj0 = colSums(pi_yj0_num)
pi_yj0 = pi_yj0_num/Pj0
# Terminos de la esperanza de shanon
SHE0 = -colSums(log(pi_yj0^pi_yj0))*Pj0
SHE1 = -colSums(log(pi_yj1^pi_yj1))*Pj1
# Esperanza de la entropia de Shannon
SHE = data.frame(matrix(SHE0 + SHE1,nrow = 1,ncol = ncol(curvaNOPAR)))
colnames(SHE) = itemsNoms
if(length(seleit) !=0){
SHE=SHE[,!colnames(SHE) %in% seleit]
}
itsel = colnames(SHE)[which.min(SHE)]
}
### Seleccion Aleatoria
if(metodoSel %in% c('Random')) {
if(length(seleit) !=0){
itEliegibles = itemsNoms[!itemsNoms %in% seleit]
itsel = sample(itEliegibles,1)
}
itsel = sample(itemsNoms,1)
}
seleit = c(seleit,itsel) # Guarda el item
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
Psuj = iccFun(a,b,c,th)
raux=runif(1,0,1)
if(raux<Psuj){respu=1}else{respu=0}
resp=c(resp,respu)
# Calcula la curva dependiendo si es NP o Parametrica
if(!is.null(curvaNOPAR)) {
curva = curvaNOPAR[,itsel]
} else {
aEst = parEst[itsel,'a']
bEst = parEst[itsel,'a']
cEst = parEst[itsel,'c']
curva = iccFun(aEst,bEst,cEst,grilla = qnorm(seqTheta))
}
#calcula verosimilitud
vero=vero*(curva^respu)*(1-curva)^(1-respu)
#plot(vero)
#estimacion de theta
if( length(unique(unlist(resp))) == 1 ){## solo aciertos o solo errores
delta=1
if(resp[1]==1){ th_est = 0.75+length(resp)*0.05
if(th_est>1){th_est=0.99}
} else { th_est = 0.25-length(resp)*0.05
if(th_est<0){th_est=0.01}
}
} else { ## si hay aciertos y errores
th_est=seqTheta[which.max(vero)]
if(length(resp)<minit){delta=1} else {delta=abs(th_est-th_vie)}
}
}
estima[s,1]=th_est
estima[s,2]=delta
estima[s,3]=length(resp)
estima[s,4]=pnorm(th)
}
return(estima)
}
res = TAIgeneric(sujtai,
epsilon,
minit,
maxit,
curvaNOPAR,
parametros,
parEst,
itemsSelec = c('InfoFun'),
matrizSelect = infoFunPar,
seqTheta = puntosNP)
## Parametros verdaderos
parametros = bancTeor[,c('NombreIt','Modelo',paste0('P',1:3))]
rownames(parametros) = apply(parametros[,c('NombreIt','Modelo')],1,function(xx) paste(xx,collapse = ''))
parametros$P3 = ifelse(is.na(parametros$P3),0,parametros$P3)
sujtai = rnorm(100)
epsilon = 0.01
minit = 10
maxit = 20
curvaNOPAR = NULL
res = TAIgeneric(sujtai,
epsilon,
minit,
maxit,
curvaNOPAR,
parametros,
parEst,
itemsSelec = c('InfoFun'),
matrizSelect = infoFunPar,
seqTheta = puntosNP)
itemsSelec = c('InfoFun')
matrizSelect = infoFunPar
seqTheta = puntosNP
estima=matrix(NA,nrow=length(sujtai),ncol=4)
s = 1
metodoSel = itemsSelec[1] # TOma el primero por defecto
itemsSelec
metodoSel = itemsSelec[1] # TOma el primero por defecto
### Nombre de los items
itemsNoms = rownames(parametros)
resp=numeric(0)
vero=1
th=sujtai[s]
th_est=runif(1,0.3,0.7)
delta=1
control=0
seleit=NULL
if(metodoSel %in% c('InfoFun','KL')) matSelAux = matrizSelect
th_vie=th_est
auxiliar = which.min(abs(seqTheta - th_est)) # Selecciona fila (theta para buscar en la matriz)
itsel = colnames(matSelAux)[which.max(matSelAux[auxiliar,])] # Selecciona el nombre del items con max Info o KL
matSelAux = matSelAux[,colnames(matSelAux) != itsel]
matSelAux
#### Metodo Shannon Entrophy
if(metodoSel %in% c('ESH')) {
veroPrev = vero
## Transforma verosimilitud en una matriz con la dimension de curvaNOPAR
veroPrev = matrix(veroPrev,ncol = 1,nrow = nrow(curvaNOPAR),byrow = F)
## Normaliza para obtener el pi_n (Ecuacion 1)
pi_n = veroPrev/sum(veroPrev)
## Numerador de la ecuacion (2)
pi_yj1_num = curvaNOPAR*pi_n
## Denominador de la ecuacion (2) (Es tambien lo que aparece en la ecuacion (3)) se devería de cancelar
Pj1 = colSums(pi_yj1_num)
## Ecuacion (2)
pi_yj1 = pi_yj1_num/Pj1
# Lo mismo para armar las ecuaciones 4 y 5
pi_yj0_num = (1 - curvaNOPAR)*pi_n
Pj0 = colSums(pi_yj0_num)
pi_yj0 = pi_yj0_num/Pj0
# Terminos de la esperanza de shanon
SHE0 = -colSums(log(pi_yj0^pi_yj0))*Pj0
SHE1 = -colSums(log(pi_yj1^pi_yj1))*Pj1
# Esperanza de la entropia de Shannon
SHE = data.frame(matrix(SHE0 + SHE1,nrow = 1,ncol = ncol(curvaNOPAR)))
colnames(SHE) = itemsNoms
if(length(seleit) !=0){
SHE=SHE[,!colnames(SHE) %in% seleit]
}
itsel = colnames(SHE)[which.min(SHE)]
}
### Seleccion Aleatoria
if(metodoSel %in% c('Random')) {
if(length(seleit) !=0){
itEliegibles = itemsNoms[!itemsNoms %in% seleit]
itsel = sample(itEliegibles,1)
}
itsel = sample(itemsNoms,1)
}
seleit = c(seleit,itsel) # Guarda el item
seleit
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
Psuj = iccFun(a,b,c,th)
raux=runif(1,0,1)
Psuj
raux
if(raux<Psuj){respu=1}else{respu=0}
resp=c(resp,respu)
resp
!is.null(curvaNOPAR)
aEst = parEst[itsel,'a']
bEst = parEst[itsel,'a']
cEst = parEst[itsel,'c']
curva = iccFun(aEst,bEst,cEst,grilla = qnorm(seqTheta))
curva
vero
#calcula verosimilitud
vero=vero*(curva^respu)*(1-curva)^(1-respu)
vero
delta=1
resp[1]==1
th_est>1
th_est = 0.25-length(resp)*0.05
th_est
th_est<0
#seleccion del item
while(delta > epsilon  & length(seleit)<maxit){
th_vie=th_est
#### Metodo de informacion de item isotonico  o KL
if(metodoSel %in% c('InfoFun','KL')) {
auxiliar = which.min(abs(seqTheta - th_est)) # Selecciona fila (theta para buscar en la matriz)
itsel = colnames(matSelAux)[which.max(matSelAux[auxiliar,])] # Selecciona el nombre del items con max Info o KL
matSelAux = matSelAux[,colnames(matSelAux) != itsel]
}
#### Metodo Shannon Entrophy
if(metodoSel %in% c('ESH')) {
veroPrev = vero
## Transforma verosimilitud en una matriz con la dimension de curvaNOPAR
veroPrev = matrix(veroPrev,ncol = 1,nrow = nrow(curvaNOPAR),byrow = F)
## Normaliza para obtener el pi_n (Ecuacion 1)
pi_n = veroPrev/sum(veroPrev)
## Numerador de la ecuacion (2)
pi_yj1_num = curvaNOPAR*pi_n
## Denominador de la ecuacion (2) (Es tambien lo que aparece en la ecuacion (3)) se devería de cancelar
Pj1 = colSums(pi_yj1_num)
## Ecuacion (2)
pi_yj1 = pi_yj1_num/Pj1
# Lo mismo para armar las ecuaciones 4 y 5
pi_yj0_num = (1 - curvaNOPAR)*pi_n
Pj0 = colSums(pi_yj0_num)
pi_yj0 = pi_yj0_num/Pj0
# Terminos de la esperanza de shanon
SHE0 = -colSums(log(pi_yj0^pi_yj0))*Pj0
SHE1 = -colSums(log(pi_yj1^pi_yj1))*Pj1
# Esperanza de la entropia de Shannon
SHE = data.frame(matrix(SHE0 + SHE1,nrow = 1,ncol = ncol(curvaNOPAR)))
colnames(SHE) = itemsNoms
if(length(seleit) !=0){
SHE=SHE[,!colnames(SHE) %in% seleit]
}
itsel = colnames(SHE)[which.min(SHE)]
}
### Seleccion Aleatoria
if(metodoSel %in% c('Random')) {
if(length(seleit) !=0){
itEliegibles = itemsNoms[!itemsNoms %in% seleit]
itsel = sample(itEliegibles,1)
}
itsel = sample(itemsNoms,1)
}
seleit = c(seleit,itsel) # Guarda el item
#simula respuesta
a=parametros[itsel,'P1']
b=parametros[itsel,'P2']
c=parametros[itsel,'P3']
Psuj = iccFun(a,b,c,th)
raux=runif(1,0,1)
if(raux<Psuj){respu=1}else{respu=0}
resp=c(resp,respu)
# Calcula la curva dependiendo si es NP o Parametrica
if(!is.null(curvaNOPAR)) {
curva = curvaNOPAR[,itsel]
} else {
aEst = parEst[itsel,'a']
bEst = parEst[itsel,'a']
cEst = parEst[itsel,'c']
curva = iccFun(aEst,bEst,cEst,grilla = qnorm(seqTheta))
}
#calcula verosimilitud
vero=vero*(curva^respu)*(1-curva)^(1-respu)
#plot(vero)
#estimacion de theta
if( length(unique(unlist(resp))) == 1 ){## solo aciertos o solo errores
delta=1
if(resp[1]==1){
th_est = min(0.75+length(resp)*0.05,0.99)
} else {
th_est = max(0.25-length(resp)*0.05,0.01)
}
} else { ## si hay aciertos y errores
th_est=seqTheta[which.max(vero)]
if(length(resp)<minit){delta=1} else {delta=abs(th_est-th_vie)}
}
}
document()
rm(list = c("TAIgeneric"))
document()
load_all()
parametros = bancTeor[,c('NombreIt','Modelo',paste0('P',1:3))]
rownames(parametros) = apply(parametros[,c('NombreIt','Modelo')],1,function(xx) paste(xx,collapse = ''))
parametros$P3 = ifelse(is.na(parametros$P3),0,parametros$P3)
sujtai = rnorm(100)
epsilon = 0.01
minit = 10
maxit = 20
curvaNOPAR = NULL
res = TAIgeneric(sujtai,
epsilon,
minit,
maxit,
curvaNOPAR,
parametros,
parEst,
itemsSelec = c('InfoFun'),
matrizSelect = infoFunPar,
seqTheta = puntosNP)
head(res)
plot(res[,c(1,4)])
cor(res[,c(1,4)])
###################################################
#### Calculo de los errores
errYses = ERRYSES(simData = res,grilla = seq(1:100)/100)
names(errYses)
lapply(errYses,head)
?TAIgeneric
library(devtools)
?mirt
library(tpm)
??tpm
