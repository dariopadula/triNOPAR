length(t)
thetaiso
length(thetaiso)
approx(fes,t,thetaiso)$y
resfin<-approx(fes,t,thetaiso)$y
resfin
plot(resfin,thetaiso)
plot(thetaiso,resfin)
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
icc1=ICCNPT$NPICC
hd=0.4
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
#'libary(here)
load_all()
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
ISINPT
names(ISINPT)
ISINPT$thataiso
ISINPT$resfin
ISINPT$puntos
thepl
thetaiso
ISINPT$puntos
thepl=qnorm(seq(0,1,0.001))
plot(thepl,ICCNPU$NPICC,col="blue",xlim=c(-4,4),ylim=c(0,1))
Prob1 <- c + (1 - c) /(1 + exp(-D * a * (thepl - b)))
points(thepl,Prob1,col="red")
thepl
ISINPT$resfin
points(thepl,ISINPT$resfin)
#'libary(here)
load_all()
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
#'libary(here)
load_all()
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
icc1=ICCNPT$NPICC
hd=0.4
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=cbind(0,puntosicc,1)
auxic=cbind(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
ifi1
#'libary(here)
load_all()
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
?approx
icc1=ICCNPT$NPICC
hd=0.4
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=cbind(0,puntosicc,1)
auxic=cbind(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
auxpu
length(auxpu)
length(puntosicc)
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
ifi1
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
### Arregla temas de borde
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)
fes=c(0.0005,fes,0.9995)
fes
length(fes)
fes[999:1002]
fes[fes>=1]
fes[fes>=1]<-0.9995
### Arregla temas de borde
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)
fes=c(0.0005,fes,0.9995)
fes
resfin<-approx(fes,t,thetaiso)$y
fes
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
fes[fes>=0.995]<-0.9995
### Arregla temas de borde
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)
fes=c(0.0005,fes,0.9995)
### Toma la reflexion respecto  a la bisectriz delcuadrado unidad
resfin<-approx(fes,t,thetaiso)$y
fes
t
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
#Se calcula la icc en los puntos i/nt
ifi1<-approx(auxpu,auxic,t)$y
t
max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0)
fes[2]
fes[1]
if(fes[2]-fes[1]>0){
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)}
else {t=c(0,t,1)}
if(fes[2]-fes[1]>0){
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)}else
{t=c(0,t,1)}
t
resfin<-approx(fes,t,thetaiso)$y
fes=c(0.0005,fes,0.9995)
resfin<-approx(fes,t,thetaiso)$y
t
length(t)
t[1002]
fes[1:10]
fes
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
#Se calcula la icc en los puntos i/nt
ifi1<-approx(auxpu,auxic,t)$y
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
fes
fes[fes>=0.995]<-0.9995
if(fes[2]-fes[1]>0){
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)}else
{t=c(0,t,1)}
fes=c(0.0005,fes,0.9995)
fes
fes[1]
fes[2]
resfin<-approx(fes,t,thetaiso)$y
fes
fes[1:10]
t{}
t[1:10]
t[999:1002]
thetaiso
resfin<-approx(fes,t,thetaiso)
icc1
icc1[1]
icc1[2]
ifi1
ifi1[1]
ifi1[2]
ifi1[5]
fes[1]
fes[2]
resfin
thetaiso
thetaiso[1002]=0.9991
thetaiso[1]
thetaiso[2]
thetaiso[1]=0.0009
resfin<-approx(fes,t,thetaiso)$y
resfin
resfin[1002]
resfin[1001]
resfin[995]
resfin[995:1002]
resfin[1]
resfin[2]
t=c(1:nt/nt)
t[length(t)]=0.9999
res=numeric(length(t))
fes=numeric(length(t))
auxpu=cbind(0,puntosiso,1)
auxic=cbind(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
t=c(1:nt/nt)
t[length(t)]=0.9999
res=numeric(length(t))
fes=numeric(length(t))
auxpu=cbind(0,puntosicc,1)
auxic=cbind(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
t=c(1:nt/nt)
t[length(t)]=0.9999
res=numeric(length(t))
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
i=1
j=1
int=list()
alu=list()
#                print(j)
#		integrand=function(x){exp(-((icc1[j]-x)/hd)^2/2)/((2*pi)^0.5)}
integrand=function(x){nucleod((ifi1[j]-x)/hd)$res}
alu[j]=integrate(integrand,-Inf,t[i],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
nucleod()
nucleod
integrand=function(x){nucleod((ifi1[j]-x)/hd,1,0)$res}
alu[j]=integrate(integrand,-Inf,t[i],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
for (i in 1:length(t)){
int=list()
alu=list()
#        print(i)
for (j in 1:length(ifi1)){
#                print(j)
#		integrand=function(x){exp(-((icc1[j]-x)/hd)^2/2)/((2*pi)^0.5)}
integrand=function(x){nucleod((ifi1[j]-x)/hd,1,0)$res}
alu[j]=integrate(integrand,-Inf,t[i],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
#                argu=(t[i]-ifi1[j])/hd
#                if(is.na(argu)){
#          		int[j]=0
#                }else{
#			int[j]=integ(argu)
#		}
}
#	res[i]=(1/(length(ifi1)))*sum(unlist(int))
fes[i]=(1/(length(ifi1)*hd))*sum(unlist(alu))
#        print(res[i])
#        print(fes[i])
}
fes
fes[1]
fes[2]
amano=fes
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)
#	res=c(0.0005,res,0.9995)
fes=c(0.0005,fes,0.9995)
#       puinterpola=seq(min(res),max(res),(max(res)-min(res))/nt)
#         puinterpola=seq(0.0005,0.9995,(0.9995-0.0005)/nt)
puinterpola=puntosicc
resfin<-approx(fes,t,puinterpola)$y
puinterpola
t
puinterpola
thetaiso=puntosicc
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
#Se calcula la icc en los puntos i/nt
ifi1<-approx(auxpu,auxic,t)$y
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
t=c(max(t[1]-((t[2]-t[1])/(fes[2]-fes[1]))*fes[1],0),t,1)
fes=c(0.0005,fes,0.9995)
resfin<-approx(fes,t,thetaiso)$y
icc1=ICCNPT$NPICC
hd=0.4
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=0.4,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
hd= 0.9*length(ICCNPT$NPICC)^(-1/5)*min(sd(ICCNPT$NPICC),(summary(ICCNPT$NPICC)[5]-summary(ICCNPT$NPICC)[2])/1.364)
ICCNPT$NPICC
summary(ICCNPT$NPICC)[2]
summary(ICCNPT$NPICC)
summary(ICCNPT$NPICC$V1)
names(summary(ICCNPT$NPICC))
summary(ICCNPT$NPICC)
summary(ICCNPT$NPICC)[[1]]
table(summary(ICCNPT$NPICC))
table(summary(ICCNPT$NPICC))[5]
summary(ICCNPT$NPICC)
sumary(ICCNPT$NPICC)
summary(ICCNPT$NPICC)
quantile(ICCNPT$NPICC,prob=0.25)
quantile(ICCNPT$NPICC,prob=0.75)
hd= 0.9*length(ICCNPT$NPICC)^(-1/5)*min(sd(ICCNPT$NPICC),(quantile(ICCNPT$NPICC,prob=0.75)-quantile(ICCNPT$NPICC,prob=0.25))/1.364)
hd
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=hdi,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
hdi= 0.9*length(ICCNPT$NPICC)^(-1/5)*min(sd(ICCNPT$NPICC),(quantile(ICCNPT$NPICC,prob=0.75)-quantile(ICCNPT$NPICC,prob=0.25))/1.364)
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=hdi,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
hdi= 0.9*length(ICCNPT$NPICC)^(-1/5)*min(sd(ICCNPT$NPICC)
thepl=qnorm(seq(0,1,0.001))
plot(thepl,ICCNPU$NPICC,col="blue",xlim=c(-4,4),ylim=c(0,1))
Prob1 <- c + (1 - c) /(1 + exp(-D * a * (thepl - b)))
points(thepl,Prob1,col="red")
points(thepl,ISINPT$resfin)
thepl=qnorm(seq(0,1,0.001))
plot(thepl,ICCNPU$NPICC,col="blue",xlim=c(-4,4),ylim=c(0,1))
Prob1 <- c + (1 - c) /(1 + exp(-D * a * (thepl - b)))
points(thepl,Prob1,col="red")
points(thepl,ISINPT$resfin)
ISINPT
thepl
ISINPT$resfin
plot(thepl,ISINPT$resfin)
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=hdi,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
ISINPT$resfin
icc1=ICCNPT$NPICC
hd=hdi
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
#Se calcula la icc en los puntos i/nt
ifi1<-approx(auxpu,auxic,t)$y
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
fes
icc1
fes
icc1=ICCNPT$NPICC
hd=0.4
thetaiso=seq(0,1,0.001)
nt=1000
puntosicc=pnorm(ICCNPT$puntos)
nucleod=epa
t=c(1:nt/nt)
t[length(t)]=0.9999
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
#Se calcula la icc en los puntos i/nt
ifi1<-approx(auxpu,auxic,t)$y
fes = sapply(1:length(t),function(ii) {
alu = sapply(ifi1, function(yy) {
integrand=function(x){nucleod((yy-x)/hd,1,0)$res}
resAlu = integrate(integrand,-Inf,t[ii],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
})
resFes = (1/(length(ifi1)*hd))*sum(alu)
})
fes
t=c(1:nt/nt)
t[length(t)]=0.9999
res=numeric(length(t))
fes=numeric(length(t))
auxpu=c(0,puntosicc,1)
auxic=c(icc1[1],icc1,1)
ifi1<-approx(auxpu,auxic,t)$y
hd
hd=hdi
hd
for (i in 1:length(t)){
int=list()
alu=list()
for (j in 1:length(ifi1)){
integrand=function(x){nucleod((ifi1[j]-x)/hd,1,0)$res}
alu[j]=integrate(integrand,-Inf,t[i],subdivisions=10,rel.tol = 0.03,abs.tol =0.05,stop.on.error = FALSE)[[1]]
}
fes[i]=(1/(length(ifi1)*hd))*sum(unlist(alu))
}
fes
library(devtools)
library(np)
#'libary(here)
load_all()
#'library(dplyr)
#'library(mirt)
#'library(psych)
#'library(MASS)
#******************************************************************
#Primero generamos data frame vacio donde iran los diferentes
#items que componen nuestro banco
#Esto se debe inicializar una sola vez a menos que se quiera cambiar
#el banco completo
bancoITEMS<- genBancoDF(nparam=15)
#Generamos un banco de 300 items
set.seed(12345)
m1pl=matrix(c(1,1,-2.5,2.5),byrow=T,ncol=2,nrow=2)
bancoITEMS=genitmodelo(1000,"1PL",m1pl,bancoITEMS)
m2pl=matrix(c(0.5,2,-2.5,2.5),byrow=T,ncol=2,nrow=2)
bancoITEMS=genitmodelo(1000,"2PL",m2pl,bancoITEMS)
m3pl=matrix(c(0.5,2,-2.5,2.5,0.2,0.4),byrow=T,ncol=2,nrow=3)
bancoITEMS=genitmodelo(1000,"3PL",m3pl,bancoITEMS)
#diseno=matrix(c(100,"2PL",100,"1PL",100,"3PL"),ncol=2,byrow = T)
diseno=matrix(c(200,"1PL"),ncol=2,byrow = T)
bancTeor = bancoTAI(bancoITEMS,diseno)
thetas=creathetas("Normal",n=10000,mean=0,sd=1)
respu=GenResp(banco = bancTeor,thetas)
# Estimacion paramétrica de los parametros en 1 dimension de bancTeor
modelo=1
#tipit<-c(rep("2PL",100),rep("Rasch",100),rep("3PL",100))
tipit<-c(rep("Rasch",200))
paramsEst = estpar(respu,modelo,tipit)
#Estimados
aest=paramsEst$parametros$items[,"a"]
best=paramsEst$parametros$items[,"b"]
cest=paramsEst$parametros$items[,"g"]
#' Calcula la correlacion y diferencia entre estimado y real en el parametro b
cor(best,bancTeor[,4])
difepar=best-bancTeor[,4]
# Habilidades
thest=paramsEst$habilidades
mean(thest)
sd(thest)
difeth=thest-thetas
# Estimacion no parametrica Caso 1 dimension
itdim1=colnames(respu)[1:200]
itemsgs=list(dim1=itdim1)
pesos=list(dim1=rep(1,200))
respG=estFunG_Simple(respu,itemsgs,pesos)
thetaest = estthetaNP(scores = respG,Dth = qnorm)
cor(thetaest[,"dtg1"],thetas)
mean(thetaest[,"dtg1"])
sd(thetaest[,"dtg1"])
difeth2=thetaest[,"dtg1"]-thetas
unido=cbind(thetas,thetaest[,"dtg1"],difeth2)
#Estimacion NP
# Estimo el item 1 NP
# uso la distribucion teorica de theta y la uniforme
hT=ventana1D(items = 1,th_use = 'dtg',test = thetaest,nucleodes="gaussian",muestra=2000)
hU=ventana1D(items = 1,th_use = 'pcg',test = thetaest,nucleodes="epanechnikov",muestra=2000)
ICCNPT=estRegNoPar(items=1,h=hT,th_use = 'dtg',test=thetaest,puntos=seq(-3,3,0.01),nucleo=normal,sigma=1)
ICCNPU=estRegNoPar(items=1,h=hU,th_use = 'pcg',test=thetaest,puntos=seq(0,1,0.001),nucleo=epa,sigma=1)
#Grafica del item 1
item=1
D=1
a=bancTeor[item,"P1"]
b=bancTeor[item,"P2"]
c=bancTeor[item,"P3"]
if(is.na(c)) c=0
thepl=ICCNPT$puntos
Prob1 <- c + (1 - c) /(1 + exp(-D * a * (thepl - b)))
estimados=paramsEst$parametros$items
ae=estimados[item,"a"]
be=estimados[item,"b"]
ce=estimados[item,"g"]
Prob2 <- ce + (1 - ce) /(1 + exp(-D * ae * (thepl - be)))
plot(thepl,Prob1,col="red",xlim=c(-4,4),ylim=c(0,1))
points(thepl,Prob2,col="cyan")
#points(thepl,icc)
points(thepl,ICCNPT$NPICC[,item],col="blue")
#Graficas 2
thepl=qnorm(seq(0,1,0.001))
plot(thepl,ICCNPU$NPICC,col="blue",xlim=c(-4,4),ylim=c(0,1))
Prob1 <- c + (1 - c) /(1 + exp(-D * a * (thepl - b)))
points(thepl,Prob1,col="red")
# Estimacion is'otona del item 1
hdi= 0.9*length(ICCNPT$NPICC)^(-1/5)*min(sd(ICCNPT$NPICC),(quantile(ICCNPT$NPICC,prob=0.75)-quantile(ICCNPT$NPICC,prob=0.25))/1.364)
ISINPT=icciso(icc1=ICCNPT$NPICC,hd=hdi,thetaiso=seq(0,1,0.001),nt=1000,puntosicc=pnorm(ICCNPT$puntos),nucleod=epa)
library(devtools)
library(np)
#'libary(here)
load_all()
#' Script de ejemplo de uso de las funciones
#'
#'
library(devtools)
library(np)
#'libary(here)
load_all()
#' Script de ejemplo de uso de las funciones
#'
#'
library(devtools)
library(np)
#'libary(here)
load_all()
#' Script de ejemplo de uso de las funciones
#'
#'
library(devtools)
#'libary(here)
load_all()
load_all()
libary(devtool)
libary(devtools)
library(devtools)
load_all()
load_all()
check()
check()
document()
document()
library(devtools)
load_all()
